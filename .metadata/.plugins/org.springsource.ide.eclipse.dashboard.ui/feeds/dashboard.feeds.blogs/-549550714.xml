<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Spring]]></title><description><![CDATA[Level up your Java code and explore what Spring can do for you.]]></description><link>https://spring.io</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 12 Oct 2023 21:32:03 GMT</lastBuildDate><item><title><![CDATA[Java Language Architect Brian Goetz]]></title><link>https://spring.io/blog/2023/10/12/java-language-architect-brian-goetz</link><guid isPermaLink="true">https://spring.io/blog/2023/10/12/java-language-architect-brian-goetz</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Thu, 12 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi, Spring fans! Are you using Java 21 in production already? No? you should listen to this episode. Yes? Then you should listen to this episode! This week, Josh Long talks to legendary Java Language Architect &lt;a href=&quot;https://twitter.com/BrianGoetz&quot;&gt;Brian Goetz (@BrianGoetz)&lt;/a&gt; recaping the latest-and-greatest and previewing Java.next&lt;/p&gt;
&lt;iframe title=&quot;Java Language Architect Brian Goetz &quot; allowtransparency=&quot;true&quot; height=&quot;150&quot; width=&quot;100%&quot; style=&quot;border: none; min-width: min(100%, 430px);height:150px;&quot; scrolling=&quot;no&quot; data-name=&quot;pb-iframe-player&quot; src=&quot;https://www.podbean.com/player-v2/?i=mt2rk-14cdb13-pb&amp;from=pb6admin&amp;share=1&amp;download=1&amp;rtl=0&amp;fonts=Arial&amp;skin=1&amp;font-color=&amp;logo_link=episode_page&amp;btn-skin=7&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Spring Framework 6.1 RC1 released]]></title><link>https://spring.io/blog/2023/10/12/spring-framework-6-1-rc1-released</link><guid isPermaLink="true">https://spring.io/blog/2023/10/12/spring-framework-6-1-rc1-released</guid><dc:creator><![CDATA[Brian Clozel]]></dc:creator><pubDate>Thu, 12 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the Spring Framework team, it is my pleasure to announce that the first Spring Framework 6.1 release candidate is available from &lt;a href=&quot;https://repo.spring.io/milestone&quot;&gt;repo.spring.io/milestone&lt;/a&gt; now.&lt;/p&gt;
&lt;p&gt;Spring Framework 6.1.0-RC1 ships &lt;a href=&quot;https://github.com/spring-projects/spring-framework/releases/tag/v6.1.0-RC1&quot;&gt;75 fixes and improvements&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;new-features&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#new-features&quot; aria-label=&quot;new features permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;New Features&lt;/h2&gt;
&lt;p&gt;This first release candidate ships a few new features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Framework 6.1 requires now a Jackson 2.14 baseline and supports the &lt;a href=&quot;https://github.com/FasterXML/jackson-databind/wiki/DatatypeFeatures&quot;&gt;new &lt;code&gt;DatatypeFeature&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;We have made further AOT improvements, reduced the runtime reflection and prepared Framework for upcoming reachability changes in GraalVM&lt;/li&gt;
&lt;li&gt;You can now use an &lt;code&gt;OutputStream&lt;/code&gt; as a source of data in reactive web APIs, thanks to a new &lt;code&gt;BodyInserter&lt;/code&gt; method variant&lt;/li&gt;
&lt;li&gt;Functional web frameworks now allow headers manipulation when serving static resources; this makes it easier to write HTTP caching response headers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will be now focusing on stabilizing APIs and behavior before the GA release in November.&lt;/p&gt;
&lt;h2 id=&quot;whats-next&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#whats-next&quot; aria-label=&quot;whats next permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;What&apos;s next&lt;/h2&gt;
&lt;p&gt;Check out our &lt;a href=&quot;https://github.com/spring-projects/spring-framework/wiki/What&amp;#x27;s-New-in-Spring-Framework-6.x&quot;&gt;What&apos;s New page&lt;/a&gt; for details about the specific features shipped so far.&lt;/p&gt;
&lt;p&gt;The first Spring Boot 3.2 release candidate &lt;a href=&quot;https://calendar.spring.io/&quot;&gt;will be released next week&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Framework 6.0.13 available now]]></title><link>https://spring.io/blog/2023/10/12/spring-framework-6-0-13-available-now</link><guid isPermaLink="true">https://spring.io/blog/2023/10/12/spring-framework-6-0-13-available-now</guid><dc:creator><![CDATA[Brian Clozel]]></dc:creator><pubDate>Thu, 12 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the team and everyone who has contributed, I am pleased to announce that Spring Framework &lt;code&gt;6.0.13&lt;/code&gt; is available now.&lt;/p&gt;
&lt;p&gt;Spring Framework &lt;code&gt;6.0.13&lt;/code&gt; ships with &lt;a href=&quot;https://github.com/spring-projects/spring-framework/releases/tag/v6.0.13&quot;&gt;34 fixes and documentation improvements&lt;/a&gt;, including &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues?q=is%3Aclosed+milestone%3A6.0.13+label%3A%22type%3A+regression%22&quot;&gt;7 fixes for regressions&lt;/a&gt;. This version will be shipped with Spring Boot 3.0.12 and 3.1.5, &lt;a href=&quot;https://calendar.spring.io/&quot;&gt;to be released next week&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We expect the next set of Spring Framework maintenance releases to ship next November, along with the new and exciting 6.1.0 we have been working on the last few months.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spring.io/projects/spring-framework/&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-framework&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues&quot;&gt;Issues&lt;/a&gt; | &lt;a href=&quot;https://docs.spring.io/spring-framework/reference/&quot;&gt;Documentation&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Transactional Rollback Strategies with Spring Cloud Stream and Apache Kafka]]></title><link>https://spring.io/blog/2023/10/11/transactional-rollback-strategies-with-spring-cloud-stream-and-apache-kafka</link><guid isPermaLink="true">https://spring.io/blog/2023/10/11/transactional-rollback-strategies-with-spring-cloud-stream-and-apache-kafka</guid><dc:creator><![CDATA[Soby Chacko]]></dc:creator><pubDate>Wed, 11 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;Other parts in this blog series&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Part 1: &lt;a href=&quot;https://spring.io/blog/2023/09/27/introduction-to-transactions-in-spring-cloud-stream-kafka-applications&quot;&gt;Introduction to Transactions in Spring Cloud Stream Kafka Applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Part 2: &lt;a href=&quot;https://spring.io/blog/2023/09/28/producer-initiated-transactions-in-spring-cloud-stream-kafka-applications&quot;&gt;Producer Initiated Transactions in Spring Cloud Stream Kafka Applications
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Part 3: &lt;a href=&quot;https://spring.io/blog/2023/10/04/synchronizing-with-external-transaction-managers-in-spring-cloud-stream&quot;&gt;Synchronizing with External Transaction Managers in Spring Cloud Stream Kafka Applications
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the last three sections of this blog series, we analyzed how transactions work in Spring Cloud Stream Kafka applications. We encountered different contexts in which transactions are helpful, including both producer and consumer applications and how an application can correctly use them. Now that those fundamental elements are behind us, let¡¯s move on to another aspect of transactions: &lt;strong&gt;rolling back a transaction when an error occurs&lt;/strong&gt;. When an error occurs and a transactional system cannot commit the transaction, the transaction manager rolls back the transaction and does not persist anything for a downstream consumer to see. It would help if an application could dictate how this rollback mechanism works. Spring Cloud Stream facilitates this rollback customization through the fundamental support in Spring for Apache Kafla. We must be aware of a few things regarding producer and consumer (&lt;strong&gt;consume-process-produce&lt;/strong&gt;) transactional applications. We take a tour through those.&lt;/p&gt;
&lt;h3 id=&quot;producer-initiated-transactions&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#producer-initiated-transactions&quot; aria-label=&quot;producer initiated transactions permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Producer-initiated transactions&lt;/h3&gt;
&lt;p&gt;Here is a code snippet that we saw before in the &lt;a href=&quot;https://spring.io/blog/2023/10/04/synchronizing-with-external-transaction-managers-in-spring-cloud-stream&quot;&gt;previous article&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional        
public void send(StreamBridge streamBridge)      
{
    for (int i = 0; i &amp;#x3C; 5; i++) {
      streamBridge.send(&quot;mySupplier-out-0&quot;, &quot;my data: &quot; + i);           
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What do we do if the transactional method throws an exception? The answer is that we need to do nothing from a Spring Cloud Stream perspective. The transaction interceptor initiates a rollback, and, ultimately, the transaction coordinator in Kafka aborts the transaction. Eventually, the exception gets propagated to the caller, and then it can decide to retrigger the transactional method if the error is transient. The framework does not retry as this is a producer-initiated transaction. This case is straightforward, as we do not need to do anything from an application or framework perspective during the transaction rollback. If an error occurs, it is guaranteed to be rolled back. However,  recall that even though the transaction was rolled back, there may be uncommitted records in the Kafka logs. Consumers with isolation level &lt;code&gt;read_uncommitted&lt;/code&gt; (the default) still receive these records. Therefore, consumer applications must ensure that they use an isolation level of &lt;code&gt;read_committed&lt;/code&gt; so that they don¡¯t receive any records rolled back by transactions upstream.&lt;/p&gt;
&lt;h3 id=&quot;producer-initiated-transactions-synchronizing-with-external-transactions&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#producer-initiated-transactions-synchronizing-with-external-transactions&quot; aria-label=&quot;producer initiated transactions synchronizing with external transactions permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Producer-Initiated Transactions Synchronizing with External Transactions&lt;/h3&gt;
&lt;p&gt;We saw this scenario in the last part of this blog series. As in the first scenario, if the method throws an exception and a rollback occurs, even if the Kafka transaction synchronizes with the database transaction, the application needs to do nothing to handle the errors. The transactions roll back from both the database and Kafka publishing.&lt;/p&gt;
&lt;h3 id=&quot;consumer-initiated-transactions-rollback&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#consumer-initiated-transactions-rollback&quot; aria-label=&quot;consumer initiated transactions rollback permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Consumer-Initiated Transactions Rollback&lt;/h3&gt;
&lt;p&gt;If producer-initiated transactions rollback is that straightforward, you might wonder what the big deal is and why we must dedicate an entire article to this topic. When is it necessary that the applications provide particular rollback strategies? It makes sense when you have a consumer-initiated transaction in progress, since we need to pay special attention to how we handle the state of the consumed records and their offsets. Let us re-examine our running consumer-initiated transactional method code from the &lt;a href=&quot;https://spring.io/blog/2023/10/04/synchronizing-with-external-transaction-managers-in-spring-cloud-stream&quot;&gt;previous blog&lt;/a&gt; in the series.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Consumer&amp;#x3C;PersonEvent&gt; process(TxCode txCode) {
   return txCode::run;
}

@Component
class TxCode {

   @Transactional
   void run(PersonEvent pe) {
       Person person = new Person();
       person.setName(pe.getName());

       Person savedPerson = repository.save(person);

       PersonEvent event = new PersonEvent();
       event.setName(savedPerson.getName());
       event.setType(&quot;PersonSaved&quot;);
       streamBridge.send(&quot;process-out-0&quot;, event);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you recall, this is a &lt;strong&gt;consume-process-produce&lt;/strong&gt; pattern done transactionally from end to end. What if the transactional method throws an exception? Here, we need to understand how the framework handles the consumed record upon rolling back the transaction. The underlying message listener container in Spring for Apache Kafka allows setting a &lt;a href=&quot;https://docs.spring.io/spring-kafka/docs/current/reference/html/#after-rollback&quot;&gt;rollback processor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The message listener container invokes the &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; API with the remaining records from the last consumer poll with the failed record at the beginning of the list. The implementations use the topic/partition information to ensure the failed record is fetched again during the next poll. When the applications enable transactions in Spring Cloud Stream, we use a default implementation called &lt;code&gt;DefaultAfterRollbackProcessor&lt;/code&gt; that implements the &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; API. Therefore, when the transaction rolls back, this implementation kicks in, by default. Let us examine what happens when this &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; is in action.&lt;/p&gt;
&lt;p&gt;Spring Cloud Stream lets you set the maximum number of method invocation retries through the consumer binding. For example, &lt;code&gt;spring.cloud.stream.bindings.&amp;#x3C;binding-name&gt;.consumer.max-attempts&lt;/code&gt;. The max attempts value includes the initial try. The default value for this is &lt;strong&gt;three&lt;/strong&gt;. If you want to disable retries, you can set this value to &lt;strong&gt;one&lt;/strong&gt;. In that case, the framework tries the record only once. The value for this is inclusive of the first try of the record. Therefore, in the default case of three, the binder retries twice after the initial attempt.&lt;/p&gt;
&lt;p&gt;When the user method throws the exception, the transaction that was originally started by the container is rolled back. Since we are in a transactional context, the container then invokes the process method of &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; in a new transaction using the transaction template, which starts a new Kafka transaction. While running the process method of &lt;code&gt;AfterRollbackProcessor&lt;/code&gt;, it checks to see if any pending retries remain, based on the max attempts configuration. If it finds more retries, it commits the current transaction, which is a no-op, since nothing occurred during the checks. A consumer seek occurs with the failed record so that the next poll returns this failed record. The consumer then polls for more records, which redelivers the failed record. The whole flow starts again and continues. If it fails again, it repeats until it exhausts all the available retries. Once all the retries are exhausted, the &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; calls the registered recoverer. Spring Cloud Stream registers a recoverer that sends the record in error to an error channel. After that, the input (recovered) record¡¯s offsets are sent to the new transaction. After this, the current transaction commits, which atomically sends the offset to the transaction and commits the record¡¯s offset. The process is complete now. The recovered record is not included in the consumer seek, and the next poll returns the new records.&lt;/p&gt;
&lt;p&gt;If the recovery fails for any reason, the container behaves as if the retries are not exhausted and gets into an endless retry. As mentioned above, when recovery succeeds, the failed record is not included in the seek, so the next poll does not return that record.&lt;/p&gt;
&lt;p&gt;Assuming that the application sets maximum attempts to be two and that the record fails both times, &lt;strong&gt;the following is the sequence of events when using transactions&lt;/strong&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The consumer polls for records, and the listener in Spring Kafka is invoked within the execute method of the &lt;code&gt;TransactionTemplate&lt;/code&gt;, which triggers the &lt;code&gt;KafkaTransactionManager&lt;/code&gt; to start a new transaction.&lt;/li&gt;
&lt;li&gt;Eventually, the listener calls the user method, which is annotated with the &lt;code&gt;@Transactional&lt;/code&gt; annotation.&lt;/li&gt;
&lt;li&gt;The transaction interceptor intercepts the transactional method and starts a new JPA  transaction by using its transaction manager.&lt;/li&gt;
&lt;li&gt;When it reaches database operation, no commit or rollback occurs, since we are in the middle of the method execution.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StreamBridge&lt;/code&gt; calls the send method, which publishes to the Kafka topic. No new Kafka transaction starts here, as there is already a Kafka transaction in progress. The same transactional resource, the producer, is used by the &lt;code&gt;KafkaTemplate&lt;/code&gt; to publish.&lt;/li&gt;
&lt;li&gt;The method throws an exception from any of its operations, and the transaction interceptor catches that and performs a rollback on the JPA transaction.&lt;/li&gt;
&lt;li&gt;The exception is propagated back to the message listener container in Spring Kafka, where the listener invoked the user method through the execute method of &lt;code&gt;TransactionTemplate&lt;/code&gt;. It then rolls back the Kafka transaction.&lt;/li&gt;
&lt;li&gt;At this point, the container invokes &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; in a new transaction, since we are in a transactional context. It starts another execute operation on its &lt;code&gt;TransactionTemplate&lt;/code&gt;, creating a new Kafka transaction by the &lt;code&gt;KafkaTransactionManager&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The execute method of the &lt;code&gt;TransactionTemplate&lt;/code&gt; invokes the process method from the &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; API and immediately returns, since one more retry is left (since we have a maximum of two attempts).&lt;/li&gt;
&lt;li&gt;The container then commits the new Kafka transaction, closing the transaction without doing anything - essentially a no-op operation.&lt;/li&gt;
&lt;li&gt;The following consumer poll re-delivers the failed record, which the container retries by calling the listener again in a new transaction (Step 1).&lt;/li&gt;
&lt;li&gt;Steps 2 - 8 repeat.&lt;/li&gt;
&lt;li&gt;The execute method of &lt;code&gt;TransactionTemplate&lt;/code&gt; invokes the process method of &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; and discovers that no more retries are left.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;process&lt;/strong&gt; method calls the registered recoverer. Since we run it as a Spring Cloud Stream application, the default recoverer sends to the error channel.&lt;/li&gt;
&lt;li&gt;After the record recovery, the offset of the recovered record (initially consumed by the consumer) offset is sent to the transaction by using the producer on the transaction.&lt;/li&gt;
&lt;li&gt;Once the &lt;strong&gt;process&lt;/strong&gt; method in &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; returns, the container calls the commit operation on the transaction, which atomically sends the offset to the transaction and performs the consumer offset commit.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Why do we need a new transaction in &lt;strong&gt;step 8&lt;/strong&gt; above, and each subsequent time it calls the &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; after a failed attempt? Why can¡¯t we call the &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; before committing the original Kafka transaction? While creating a new Kafka transaction after each failed attempt to perform after-rollback tasks may sound like unneeded overhead, this is necessary. When a rollback occurs in the original transaction, it does not send the offset to the transaction. If there is a retry, the container calls the listener again in a new transaction, and the cycle continues until the retries exhaust and the record is recovered. There are potentially as many transactions created by the container and rolled back as the number of max attempts without sending the offsets to the transaction. Each time the original transaction rolls back, the container starts a corresponding new transaction for the &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; invocation, whose commits are no-ops (except for the last one after the recovery). After recovering the record, this last invocation sends the offsets to the transaction for atomically committing the offsets and do the necessary transactional cleanups on the Kafka side. Therefore, as we can see, to send the offsets to the transaction, we need to invoke the &lt;code&gt;AfterRollbackProcessor&lt;/code&gt; in a new transaction.&lt;/p&gt;
&lt;h3 id=&quot;customizing-the-afterrollbackprocessor&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#customizing-the-afterrollbackprocessor&quot; aria-label=&quot;customizing the afterrollbackprocessor permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Customizing the AfterRollbackProcessor&lt;/h3&gt;
&lt;p&gt;If an application wants to customize the after-rollback tasks, rather than using the default - &lt;code&gt;DefaultAfterRollbackProcessor&lt;/code&gt; - used by Spring Cloud Stream, then it can use the &lt;code&gt;ListenerContainerCustomizer&lt;/code&gt; to provide a custom &lt;code&gt;AfterRollbackProcessor&lt;/code&gt;. The following listing shows how to do so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
public ListenerContainerCustomizer&amp;#x3C;AbstractMessageListenerContainer&amp;#x3C;byte[], byte[]&gt;&gt; customizer() {
   return (container, destination, group) -&gt; container.setAfterRollbackProcessor(
           new DefaultAfterRollbackProcessor&amp;#x3C;byte[], byte[]&gt;(
                   (record, exception) -&gt; System.out.println(&quot;Discarding failed record: &quot; + record),
                   new FixedBackOff(0L, 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When providing the above customization, the recoverer logs the error and moves on. The constructor of the &lt;code&gt;DefaultAfterRollbackProcessor&lt;/code&gt; also takes a &lt;strong&gt;backoff&lt;/strong&gt; with no retries. Therefore, in this example, as soon as the first time an exception occurs in the method, the record is recovered by logging.&lt;/p&gt;
&lt;h3 id=&quot;transactional-dlq-publishing-during-record-recovery&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#transactional-dlq-publishing-during-record-recovery&quot; aria-label=&quot;transactional dlq publishing during record recovery permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Transactional DLQ Publishing During Record Recovery&lt;/h3&gt;
&lt;p&gt;Spring Cloud Stream lets you send the failed records after it exhausts all retries to a unique &lt;strong&gt;DLQ&lt;/strong&gt; (Dead Letter Queue) topic as part of the recovery process. We mentioned that the &lt;code&gt;DefaultAfterRollbackProcessor&lt;/code&gt; used by the Spring Cloud Stream Kafka binder sends the record to an error channel. When an application enables &lt;strong&gt;DLQ&lt;/strong&gt;, the binder sends the failed record to a special &lt;strong&gt;DLT&lt;/strong&gt; topic. The details of how this happens are outside the scope of our transaction discussions. However, the question is whether the &lt;strong&gt;DLT&lt;/strong&gt; publishing is transactional or not. When setting up the &lt;strong&gt;DLQ&lt;/strong&gt; infrastructure, if the application uses transactions (that is, it provides the &lt;code&gt;transaction-id-prefix&lt;/code&gt;) the binder uses the same original transactional producer factory used in the &lt;code&gt;KafkaTransactionManager&lt;/code&gt;. Therefore, the framework guarantees to publish to the &lt;strong&gt;DLT&lt;/strong&gt; transactionally.&lt;/p&gt;
&lt;p&gt;With the discussions in this article, we covered all the major building blocks of transactions when using them in a Spring Cloud Stream Kafka application. In the next section of this blog series, we will look at a practical application of transactions in Kafka, the popular exactly-once-semantics, and how we can enable them in a Spring Cloud Stream Kafka application.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[This Week in Spring - October 10th, 2023]]></title><link>https://spring.io/blog/2023/10/10/this-week-in-spring-october-10th-2023</link><guid isPermaLink="true">https://spring.io/blog/2023/10/10/this-week-in-spring-october-10th-2023</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Tue, 10 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi, Spring fans! Welcome to another installment of &lt;em&gt;This Week in Spring&lt;/em&gt;! Last week I was in Antwerp, Belgium, for the amazing Devoxx Belgium event, and this week I&apos;ve been in Amsterdam for the SpringOne Tour Amsterdam stop and - in the middle of the SpringOne Tour Amsterdam event - I dipped out to join my friend and fellow Java Champion &lt;a href=&quot;https://twitter.com/trustin&quot;&gt;Trustin Lee (@trustin)&lt;/a&gt; (he created Netty! the guy&apos;s a living legend!) for a discussion and ask-me-anything at the local Amsterdam Java User Group, hosted by fellow Java Champion and local &lt;a href=&quot;https://twitter.com/GeertjanW&quot;&gt;Geertjan Wielenga (@GeertjanW)&lt;/a&gt;. It was a lovely day indeed across the two different events, and I&apos;m grateful to have been a part of it. Now I&apos;m in Switzerland, where tonight I&apos;ll be speaking at the local &lt;a href=&quot;https://www.jug.ch/eventpreview.php?id=859&quot;&gt;Bern Java User Group&lt;/a&gt; with my &lt;a href=&quot;https://twitter.com/ciberkleid&quot;&gt;colleague and friend Cora Iberkleid (@ciberkleid)&lt;/a&gt;. And tomorrow, at long last, I head home.&lt;/p&gt;
&lt;p&gt;We&apos;ve got a busy week&apos;s review ahead, so let&apos;s dive right into it!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/10/05/a-bootiful-podcast-spring-data-legend-greg-turnquist-on-optimizations-and&quot;&gt;A Bootiful Podcast: Spring Data legend Greg Turnquist on optimizations and queries and more&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QLRIaj8w3-s&quot;&gt;AxonIQ Conference 2023 Keynote: Axon&apos;s Bootiful History with Josh Long&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://auth0.com/blog/java-spring-boot-microservices/&quot;&gt;Java Microservices with Spring Boot and Spring Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/10/04/spring-shell-2-1-13-3-0-8-and-3-1-4-are-now-available&quot;&gt;Spring Shell 2.1.13, 3.0.8 and 3.1.4 are now available&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;when I was at Devoxx I &lt;a href=&quot;https://www.youtube.com/watch?v=46A7rsKNSxQ&quot;&gt;interviewed Java language architect, Oracle, Brian Goetz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;are you a novice learning Java? Welcoem to the ecosystem! there&apos;s never been a better time to be a Java engineer! And I want to help people take their first steps. In this video, we do a Java programmer desk check, looking at the tools and resources you&apos;ll need to have installed to start writing &lt;a href=&quot;https://www.youtube.com/watch?v=gU4iFZIDoig&quot;&gt;the famous &quot;Hello, world&quot; example!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;when I was at Devoxx I interviewed &lt;a href=&quot;https://www.youtube.com/watch?v=JpUxIi7JULY&quot;&gt;GraalVM founder and vice president, Oracle, Thomas Wuerthinger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;when I was at the SpringOne Tour Amsterdam event I interviewed former SpringSourcer and longtime friend of the Java and &lt;a href=&quot;https://www.youtube.com/watch?v=97zcc5nKv40&quot;&gt;Spring communities Joris Kuipers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;I interviewed &lt;a href=&quot;https://www.youtube.com/watch?v=97zcc5nKv40&quot;&gt;Java community legend Alexis Moussine-Pouchkine&lt;/a&gt;, Google, a long wandering member of the tribes of Sun Microsystems.&lt;/li&gt;
&lt;li&gt;I interviewed &lt;a href=&quot;https://www.youtube.com/watch?v=G8F8qJM1kxI&quot;&gt;Azul deputy CTO Simon Ritter at Devoxx BE and it was dope&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;when I was at Devoxx I interviewed Roni Dover, &lt;a href=&quot;https://www.youtube.com/watch?v=F_16GB2DIMo&quot;&gt;CTO and cofounder of Digma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/blog/2023/10/10/cri-o-community-package-infrastructure/&quot;&gt;Blog: CRI-O is moving towards pkgs.k8s.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/blog/2023/10/05/sig-architecture-conformance-spotlight-2023/&quot;&gt;Blog: Spotlight on SIG Architecture: Conformance&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[A Bootiful Podcast: Spring Data legend Greg Turnquist on optimizations and queries and more]]></title><link>https://spring.io/blog/2023/10/05/a-bootiful-podcast-spring-data-legend-greg-turnquist-on-optimizations-and</link><guid isPermaLink="true">https://spring.io/blog/2023/10/05/a-bootiful-podcast-spring-data-legend-greg-turnquist-on-optimizations-and</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Thu, 05 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi, Spring fans! In this installment, we&apos;ll talk to Spring Data legend &lt;a href=&quot;https://twitter.com/gregturn&quot;&gt;Greg Turnquist (@gregturn)&lt;/a&gt; about the incredible next-level optimizations and query enhancements, the work in general, and so much more. Recorded live at SpringOne 2023 in Las Vegas!&lt;/p&gt;
&lt;iframe title=&quot;Spring Data legend Greg Turnquist on optimizations, queries, and more&quot; allowtransparency=&quot;true&quot; height=&quot;150&quot; width=&quot;100%&quot; style=&quot;border: none; min-width: min(100%, 430px);height:150px;&quot; scrolling=&quot;no&quot; data-name=&quot;pb-iframe-player&quot; src=&quot;https://www.podbean.com/player-v2/?i=7h6h3-14c244d-pb&amp;from=pb6admin&amp;share=1&amp;download=1&amp;rtl=0&amp;fonts=Arial&amp;skin=1&amp;font-color=&amp;logo_link=episode_page&amp;btn-skin=7&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Synchronizing with External Transaction Managers in Spring Cloud Stream Kafka Applications]]></title><link>https://spring.io/blog/2023/10/04/synchronizing-with-external-transaction-managers-in-spring-cloud-stream</link><guid isPermaLink="true">https://spring.io/blog/2023/10/04/synchronizing-with-external-transaction-managers-in-spring-cloud-stream</guid><dc:creator><![CDATA[Soby Chacko]]></dc:creator><pubDate>Wed, 04 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;Other parts in this blog series&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Part 1: &lt;a href=&quot;https://spring.io/blog/2023/09/27/introduction-to-transactions-in-spring-cloud-stream-kafka-applications&quot;&gt;Introduction to Transactions in Spring Cloud Stream Kafka Applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Part 2: &lt;a href=&quot;https://spring.io/blog/2023/09/28/producer-initiated-transactions-in-spring-cloud-stream-kafka-applications&quot;&gt;Producer Initiated Transactions in Spring Cloud Stream Kafka Applications
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&quot;https://spring.io/blog/2023/09/28/producer-initiated-transactions-in-spring-cloud-stream-kafka-applications&quot;&gt;previous part&lt;/a&gt; of this blog series, we saw the basics of transaction management, primarily when using producer-initiated Spring Cloud Stream Kafka applications. In that discussion, we also briefly saw how a Spring Cloud Stream Kafka consumer application could consume records produced transactionally with proper isolation levels. When you synchronize with external transaction managers, such as one for a relational database, we mentioned that you must use transactions to ensure data integrity. In this part, we will see how we can accomplish transactional guarantees in Spring Cloud Stream when using external transaction managers.&lt;/p&gt;
&lt;p&gt;Before we start this exploration, it is important to remember that achieving distributed transactions is extremely difficult in practice. You must rely on 2 phase commit (2PC) strategies and a properly distributed transaction manager, such as a JTA-compatible transaction manager, to do this properly. Nevertheless, most enterprise use cases may not require this level of complexity, and most use cases that we consider and see people use in practice may be better off by sticking with the non-distributed transactional methods, as we describe in this blog. &lt;a href=&quot;https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html&quot;&gt;This article&lt;/a&gt;, by &lt;a href=&quot;https://spring.io/team/dsyer&quot;&gt;Dr.Dave Syer&lt;/a&gt; of the Spring engineering team, published back in 2009, is still relevant (even after 14 years) to understanding the challenges of distributed transactions and the recommended alternative approaches in Spring.&lt;/p&gt;
&lt;p&gt;Let¡¯s return to our discussion: achieving transactionality in Spring Cloud Stream Kafka application when using external transaction managers in producer-initiated and consume-process-produce (read-process-write) applications.&lt;/p&gt;
&lt;p&gt;Now we can set the stage for our discussion in an example domain by sketching out some code that we can work through in the discussion. We use a few domain objects to drive the demo and have created pseudo-code for them.&lt;/p&gt;
&lt;p&gt;Assume that the messaging system deals with ¡°event¡± domain types - let&apos;s use a &lt;strong&gt;PersonEvent&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class PersonEvent {

   String name;
   String type;

   //Rest omitted for brevity
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also need a Domain Entity for the &lt;strong&gt;Person&lt;/strong&gt; object:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Entity
@Table(name = &quot;person&quot;)
public class Person {

   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long id;

   private String name;

   // Rest omitted for brevity
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we need a &lt;strong&gt;CrudRepository&lt;/strong&gt; for the &lt;strong&gt;Person&lt;/strong&gt; domain object:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface PersonRepository extends CrudRepository&amp;#x3C;Person, String&gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the case of a producer-initiated scenario, assume that, when a method is called (via REST, for example), a &lt;strong&gt;Person&lt;/strong&gt; domain object is created, persists to the database, and is sent as a &lt;strong&gt;PersonEvent&lt;/strong&gt; to an outbound Kafka topic through &lt;code&gt;StreamBridge&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the case of the &lt;strong&gt;consume-process-produce&lt;/strong&gt; scenario, assume that the input topic receives a &lt;strong&gt;PersonEvent&lt;/strong&gt;, from which the processor generates a &lt;strong&gt;Person&lt;/strong&gt; domain object to persist to a database. Finally, it produces another &lt;strong&gt;PersonEvent&lt;/strong&gt; to an outbound Kafka topic.&lt;/p&gt;
&lt;p&gt;Let¡¯s also use JPA for our discussions here. Spring Cloud Stream applications are Boot applications, and you can include the spring-boot-starter-jpa dependency in the application and include the appropriate spring.jpa.* properties to drive the necessary autoconfiguration. The assumption is that Spring Boot will autoconfigure a &lt;code&gt;JPATransactionManager&lt;/code&gt; for us.&lt;/p&gt;
&lt;p&gt;Let us break down our use cases into various scenarios.&lt;/p&gt;
&lt;h2 id=&quot;scenario-1-producer-initiated-transactions&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#scenario-1-producer-initiated-transactions&quot; aria-label=&quot;scenario 1 producer initiated transactions permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Scenario 1: Producer-initiated transactions&lt;/h2&gt;
&lt;p&gt;In the producer-initiated scenario, we have two operations that we must do transactionally: a database operation followed by a Kafka publishing operation. Here is the basic idea. Keep in mind that this code shows only the crux of what is involved. In real-world settings, the code will almost certainly be much more complex than this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
Sender sender;

@PostMapping(&quot;/send-data&quot;)
public void sendData() {
   sender.send(streamBridge, repository);
}

@Component
static class Sender {

   @Transactional
   public void send(StreamBridge streamBridge, PersonRepository repository) {
       Person person = new Person();
       person.setName(&quot;Some Person&quot;);

       Person savedPerson = repository.save(person);

       PersonEvent event = new PersonEvent();
       event.setName(savedPerson.getName());
       event.setType(&quot;PersonSaved&quot;);
       streamBridge.send(&quot;process-out-0&quot;, event);
   }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above producer-initiated code is fully transactional. In the previous part of this blog, we saw that more than adding just the &lt;code&gt;Transactional&lt;/code&gt; annotation is needed if you only have a Kafka transaction. As discussed, the &lt;code&gt;Transactional&lt;/code&gt; annotation did not have a transaction manager, and we needed a custom transaction manager that uses the same underlying transactional resources to achieve transactionality. Here, however, the situation is different. We have the &lt;code&gt;JpaTransactionManager&lt;/code&gt; autoconfigured by Spring Boot, and the transaction interceptor uses that to start a transaction. Since we have the &lt;strong&gt;transaction-id-prefix&lt;/strong&gt; configured, the &lt;code&gt;StreamBridge&lt;/code&gt; send operation can be done transactionally. However, &lt;code&gt;KafkaTemplate&lt;/code&gt; synchronizes the Kafka transaction with the already existing JPA transaction through the &lt;code&gt;TransactionSynchronizationManager&lt;/code&gt;. Upon method exit, the primary transaction is committed first, followed by the synchronized transactions, which, in this case, is the Kafka transaction.&lt;/p&gt;
&lt;h5 id=&quot;the-following-is-the-sequence-in-this-flow&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#the-following-is-the-sequence-in-this-flow&quot; aria-label=&quot;the following is the sequence in this flow permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The following is the sequence in this flow.&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;The JPA transaction manager starts a new JPA transaction.&lt;/li&gt;
&lt;li&gt;The database operation commences, but no commit occurs here since we are still in the method execution.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;StreamBridge&lt;/code&gt; send operation triggers a new Kafka transaction, synchronizing with the JPA transaction through the transaction synchronization manager.&lt;/li&gt;
&lt;li&gt;When the method exits, the JPA transaction is committed first, followed by the Kafka transaction.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;A general note on synchronizing transactions in Spring:&lt;/strong&gt; It might sound like it is doing complex transaction synchronization behind the scenes. However, as we implied at the opening of this article, there is no distributed transaction synchronization going on here, let alone any intelligent ways to synchronize between the various transactions. The transactions themselves do not know anything about the synchronization. The Spring &lt;code&gt;TransactionSynchronizatonManager&lt;/code&gt; simply coordinates the commits and rollbacks of multiple transactions. Synchronizing transactions in this context is functionally similar to nesting two or more &lt;code&gt;@Transactional&lt;/code&gt; methods or &lt;code&gt;TransactionTempate&lt;/code&gt; objects. There is less to configure because Spring does the nesting for you.&lt;/p&gt;
&lt;h2 id=&quot;scenario-2-reversing-the-order-of-commits&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#scenario-2-reversing-the-order-of-commits&quot; aria-label=&quot;scenario 2 reversing the order of commits permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Scenario 2: Reversing the Order of Commits&lt;/h2&gt;
&lt;p&gt;Suppose we need to reverse the order of commits due to some new requirements in the flow, with the Kafka transaction getting committed first instead of the JPA one. How do we do that? One solution that might intuitively come to us is to explicitly provide a Kafka transaction manager to the &lt;code&gt;@Transactional&lt;/code&gt; annotation and let the JPA transaction synchronize with the Kafka transaction, which is the primary one. The code looks like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(¡°customKafkaTransactionManager)
public void send(StreamBridge streamBridge, PersonRepository repository) {
    Person person = new Person();
    person.setName(&quot;Some Person&quot;);

    Person savedPerson = repository.save(person);

    PersonEvent event = new PersonEvent();
    event.setName(savedPerson.getName());
    event.setType(&quot;PersonSaved&quot;);
    streamBridge.send(&quot;process-out-0&quot;, event);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to provide a custom Kafka transaction manager:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
KafkaTransactionManager customKafkaTransactionManager() {
   KafkaMessageChannelBinder kafka = (KafkaMessageChannelBinder) this.binderFactory.getBinder(&quot;kafka&quot;, MessageChannel.class);
   ProducerFactory&amp;#x3C;byte[], byte[]&gt; transactionalProducerFactory = kafka.getTransactionalProducerFactory();
   KafkaTransactionManager kafkaTransactionManager = new KafkaTransactionManager(transactionalProducerFactory);
   return kafkaTransactionManager;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since Spring Boot does not configure a transaction manager if it detects one already present, we must configure the JPA transaction manager ourselves:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
public PlatformTransactionManager transactionManager(
       ObjectProvider&amp;#x3C;TransactionManagerCustomizers&gt; transactionManagerCustomizers) {
   JpaTransactionManager transactionManager = new JpaTransactionManager();
   transactionManagerCustomizers.ifAvailable((customizers) -&gt; customizers.customize(transactionManager));
   return transactionManager;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Did our intuition work here? Have we successfully changed the order of applying transactions? Unfortunately, no. It does not work, because the JPA transaction manager does not let its transaction synchronize with other transactions, such as the one from the primary transaction manager in this case (the custom Kafka transaction manager). In our case, although we made a custom Kafka transaction manager to be the primary one, the JPA transaction starts and commits by itself without synchronizing with the primary upon executing the repository save method.&lt;/p&gt;
&lt;h5 id=&quot;the-order-of-events-in-this-flow-is-as-follows&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#the-order-of-events-in-this-flow-is-as-follows&quot; aria-label=&quot;the order of events in this flow is as follows permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The order of events in this flow is as follows&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;The Kafka transaction manager starts a new transaction that the interceptor uses.&lt;/li&gt;
&lt;li&gt;When the repository save method executes, a JPA transaction is created by the JpaTransactionManager without synchronizing with the primary transaction.&lt;/li&gt;
&lt;li&gt;The JPA transaction commits while still within the method execution.&lt;/li&gt;
&lt;li&gt;The interceptor will commit the Kafka transaction upon exiting the method.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;How can we reverse the transactions, then? There are two ways to do this.&lt;/p&gt;
&lt;p&gt;First, we can try chaining the transaction managers. &lt;a href=&quot;https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/transaction/ChainedTransactionManager.html&quot;&gt;ChainedTransactionManager&lt;/a&gt; is a transaction manager implementation from the &lt;a href=&quot;https://spring.io/projects/spring-data&quot;&gt;Spring Data&lt;/a&gt; project. You can specify the list of transaction managers to the &lt;code&gt;ChainedTransactionManager&lt;/code&gt;, and it starts the transaction in the order of transaction managers in its list. On the way out (that is, when the method exits), the transactions are committed in the reverse order of the list of transaction managers.&lt;/p&gt;
&lt;p&gt;While this sounds like a reasonable strategy, one big caveat to keep in mind is that &lt;code&gt;ChainedTransactionManager&lt;/code&gt; is currently deprecated and not a recommended option. The reason for the deprecation is in the &lt;a href=&quot;https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/transaction/ChainedTransactionManager.html&quot;&gt;Javadoc&lt;/a&gt;. The gist is that people often expect the &lt;code&gt;ChainedTransactionManager&lt;/code&gt; to be a magical silver bullet that solves all the transactional issues, including distributed transactions with two-phase commits and other issues, while this couldn¡¯t be further away from the truth. &lt;code&gt;ChainedTransactionManager&lt;/code&gt; ensures only that the transactions are started and committed in a particular order. It doesn&apos;t guarantee any transaction synchronization, let alone any distributed transaction coordination. Suppose you are comfortable with the limitations of &lt;code&gt;ChainedTransactionManager&lt;/code&gt; and want a particular order, as our use case requires. In that case, it is reasonable to use this transaction manager as long as you remember that you are using a deprecated class from the framework.&lt;/p&gt;
&lt;p&gt;Let us try &lt;code&gt;ChainedTransactionManager&lt;/code&gt; in our scenario and see how it goes. Spring for Apache Kafka provides a subclass called ChainedKafkaTransactionManager, which is also deprecated because the parent class is deprecated.&lt;/p&gt;
&lt;p&gt;We use the same custom &lt;code&gt;KafkaTransactionManager&lt;/code&gt; bean that we saw before in the chained transactions.&lt;/p&gt;
&lt;p&gt;We also need to create the &lt;code&gt;JpaTransactionManager&lt;/code&gt; bean, as before, since Spring Boot does not auto-configure it, because it already detects the custom &lt;code&gt;KafkaTransactionManager&lt;/code&gt; bean.&lt;/p&gt;
&lt;p&gt;Once we add those two beans, let¡¯s create the &lt;code&gt;ChainedKafkaTransactionManager&lt;/code&gt; bean:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
public ChainedKafkaTransactionManager chainedKafkaTransactionManager(KafkaTransactionManager kafkaTransactionManager, PlatformTransactionManager transactionManager) {
   return new ChainedKafkaTransactionManager(jpaTransactionManager, kafkaTransactionManager);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these in place, let¡¯s modify our Transactional annotation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(&quot;chainedKafkaTransactionManager&quot;)
public void send(StreamBridge streamBridge, PersonRepository repository) {
..
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above configuration accomplishes the result we want. When you run this application, we reverse the transactions, as expected - that is, Kafka will commit first, followed by the JPA.&lt;/p&gt;
&lt;h5 id=&quot;here-are-the-steps-in-the-flow&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#here-are-the-steps-in-the-flow&quot; aria-label=&quot;here are the steps in the flow permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Here are the steps in the flow&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;TransactionInterceptor uses the custom &lt;code&gt;ChainedKafkaTransactionManager&lt;/code&gt; to start the transaction. It starts the  Jpa transaction using the &lt;code&gt;JpaTransactionManager&lt;/code&gt; and does the same for the &lt;code&gt;KafkaTransactionManager&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When the method calls the database operation, since it already runs within a JPA transaction, it doesn¡¯t start another one. No commit or rollback occurs here since this is not a new transaction.&lt;/li&gt;
&lt;li&gt;Next, the method performs the Kafka publishing through &lt;code&gt;StreamBridge&lt;/code&gt;. We see the same deal here as we saw for JPA, above. Since there is an already existing Kafka transaction, it does not start a new Kafka transaction. The &lt;code&gt;StreamBridge&lt;/code&gt; send operation occurs by using the same transactional producer factory that was used by the initial Kafka transaction. No commits or rollbacks occur here.&lt;/li&gt;
&lt;li&gt;When the method exits, the chained transaction manager goes in reverse order, starting with the Kafka transaction commit (or rolling back), followed by the JPA one.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you are comfortable with the limitations of the chained transaction manager, this approach works. Remember that there is no transaction synchronization here. The transaction managers are applied in the order given when the transactions begin and reverse order on the way out when committing or rolling back. If you are going with this route, since you are using deprecated classes in the framework, copying them and using them in your project will be a good idea rather than relying on the framework. Since they are deprecated, no new features and bug fixes are guaranteed. A future version can drop them altogether. It is also possible that this may never be removed and that the deprecation status is present to discourage its use (due to people thinking it has greater functionality than it really does).&lt;/p&gt;
&lt;p&gt;If you do not want to rely on deprecated classes from the framework or do not want to copy them and maintain them on your end, you have another option to try. You can create two transactional methods and nest the calls. Here is a blueprint for that idea:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
static class Sender {

       @Transactional(&quot;jpaTransactionManager&quot;)
       public void send(StreamBridge streamBridge, PersonRepository repository, KafkaSender kafkaSender) {
           Person person = new Person();
           person.setName(&quot;Some Person&quot;);

           Person savedPerson = repository.save(person);

           PersonEvent event = new PersonEvent();
           event.setName(savedPerson.getName());
           event.setType(&quot;PersonSaved&quot;);
           kafkaSender.send(streamBridge, event);
       }
}

@Component
static class KafkaSender {
       @Transactional(&quot;customKafkaTransactionManager&quot;)
       public void send(StreamBridge streamBridge, PersonEvent event) {
           streamBridge.send(&quot;process-out-0&quot;, event);
       }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ensure that the nested call is in a different class for the reasons we went through in &lt;a href=&quot;https://spring.io/blog/2023/09/28/producer-initiated-transactions-in-spring-cloud-stream-kafka-applications&quot;&gt;part 2&lt;/a&gt; of this blog series, because of how AOP proxying works in Spring.&lt;/p&gt;
&lt;p&gt;Both methods, in this case, are transactional, and they are nested. When the transaction interceptor intercepts the first method call, it starts the JPA transaction. In the middle of the execution, the nested call (whose method also has the &lt;code&gt;@Transactional&lt;/code&gt; annotation) comes in. Since this bean method has the &lt;code&gt;@Transactional&lt;/code&gt; annotation, Spring AOP wraps the bean in an AOP advice. Because we call this advised bean from another bean in a different class, the proxy mechanism properly invokes the advised bean. Another transaction interceptor starts a new transaction by using a different transaction manager (that is, the &lt;code&gt;KafkaTransactionManager&lt;/code&gt;). When Kafka publishing occurs, the transaction does not immediately commit or roll back, since the transaction started as part of the method, and the commit or roll-back happens when the method exits. At that point, the control returns to the first method and continues. Once it exits the original method, the JPA transaction is committed through the interceptor. If the method that publishes to Kafka throws an exception, it rolls back that transaction. In that case, after rolling back, the exception propagates back to the first transactional method (the JPA one), which also rolls back its transaction due to the exception.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;An important note when using this technique&lt;/strong&gt;  The call to the nested method should be the last thing the first method does because, if the first method fails to execute some code after the Kafka call, which went successfully, the Kafka transaction has already been committed. The failure in the first method does not automatically roll back the Kafka transaction.&lt;/p&gt;
&lt;h2 id=&quot;scenario-3-consume-process-produce&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#scenario-3-consume-process-produce&quot; aria-label=&quot;scenario 3 consume process produce permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Scenario 3: Consume-Process-Produce&lt;/h2&gt;
&lt;p&gt;With the core understanding we gained about transactions in this series so far, let¡¯s look at a crucial pattern in event-driven and streaming applications called the &lt;strong&gt;consume-process-produce&lt;/strong&gt; pattern. In Spring Cloud Stream, an implementation of such a pattern looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
public Function&amp;#x3C;PersonEvent, PersonEvent&gt; process(TxCode txCode) {
  return pe -&gt; txCode.run(pe);
}

@Component
class TxCode {

   @Transactional
   PersonEvent run(PersonEvent pe) {
       Person person = new Person();
       person.setName(pe.getName());

       Person savedPerson = repository.save(person);

       PersonEvent event = new PersonEvent();
       event.setName(savedPerson.getName());
       event.setType(&quot;PersonSaved&quot;);
       return event;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have a Spring Cloud Stream function that consumes &lt;code&gt;PersonEvent&lt;/code&gt; from an input topic and then calls a function to process in the body of the function¡¯s lambda expression. This function returns another &lt;code&gt;PersonEvent&lt;/code&gt;, which we publish to the outbound Kafka topic. If we are not in a transactional context, we can inline the &lt;code&gt;run&lt;/code&gt; method above as part of the function¡¯s lambda expression. However, to achieve transactional semantics, the &lt;code&gt;@Transactional&lt;/code&gt; annotation must be on a method in a different class.&lt;/p&gt;
&lt;p&gt;To make the binder transactional, make sure that you provide the &lt;code&gt;spring.cloud.stream.kafka.binder.transaction.transaction-id-prefix&lt;/code&gt; with a valid value.&lt;/p&gt;
&lt;p&gt;Is the code above fully transactional? The reality, however, is that it is only partially transactional end-to-end. Let¡¯s look at the sequence of events.&lt;/p&gt;
&lt;p&gt;The binder is transactional, because we provide the &lt;code&gt;transaction-id-prefix&lt;/code&gt;. When the consumer polls for the records in the message listener container, it invokes the internal listener method within its &lt;code&gt;TrasactionTemplate#execute&lt;/code&gt; method. Therefore, the whole end-to-end process of executing the listener method (which invokes the user method) runs within a transaction started by the &lt;code&gt;KafkaTransactionManager&lt;/code&gt;. When the transaction starts, the &lt;code&gt;TransactionSynchronizationManager&lt;/code&gt; binds the resources (the producer) to the transaction. When the user method (the method annotated with &lt;code&gt;@Transactional&lt;/code&gt;) gets called, the transaction interceptor intercepts that call, letting the wrapped AOP advice take care of the actual invocation. Because we have a &lt;code&gt;JpaTransactionManager&lt;/code&gt;, the transaction interceptor uses that manager and starts a new transaction. It is up to each transaction manager implementation to decide whether it wants to synchronize with an existing transaction. In the case of JpaTransactionManager (and many other similar database transaction manager implementations), it does not allow synchronization with an existing transaction as we already discussed above. Therefore, the JPA transaction runs independently, as seen in the above sections. When the run method exits, the transaction interceptor does a commit or rollback operation by using the JPA transaction manager. With that, the JPA transaction manager finishes its job. At this point, the response from the method invocation goes back to the caller, which is the Spring Cloud Stream infrastructure. This mechanism in Spring Cloud Stream takes this response and sends it to the outbound topic in Kafka. It uses the same transactional producer bound when the initial transaction began. After sending the record, the control returns to the message listener container, which then commits or rolls back the transaction.&lt;/p&gt;
&lt;h5 id=&quot;here-are-the-steps-in-this-sequence&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#here-are-the-steps-in-this-sequence&quot; aria-label=&quot;here are the steps in this sequence permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Here are the steps in this sequence&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;The Kafka consumer receives the record.&lt;/li&gt;
&lt;li&gt;The container in Spring Kafka invokes the listener by using the &lt;code&gt;execute&lt;/code&gt; method of the &lt;code&gt;TransactionTemplate&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;KafkaTransactionManager starts a new transaction.
3. The Kafka resources are bound (producer).
4. When it reaches the user code, the transaction interceptor eventually intercepts that call and starts a new JPA transaction.
5. The AOP proxy then invokes the actual method.
When the method exits, the &lt;code&gt;JpaTransactionManager&lt;/code&gt; commits or rolls back.
6. The method¡¯s output returns to the caller in Spring Cloud Stream.
7. The response is then sent to Kafka outbound using the same transactional resource from step 4.
8. The control returns to the message listener container and the &lt;code&gt;KafkaTransactionManager&lt;/code&gt; commits or rolls back.&lt;/p&gt;
&lt;p&gt;So, what is the issue here? It looks transactional, but, in reality, it is only partially so. The main problem at the outset is that the whole end-to-end process is outside the bounds of a single atomic transaction, which is a significant issue. There are two transactions here - Kafka and JPA - and there is no synchronization between the JPA and Kafka transactions. If the database transaction got committed and the Kafka sending failed, there is no way to roll back the JPA transaction.&lt;/p&gt;
&lt;p&gt;We might think that &lt;code&gt;ChainedTransactionManager&lt;/code&gt; could help here. While that intuition has some merits, it doesn¡¯t work with the above code. Because of the Kafka transaction created in the container while invoking the listener method, &lt;code&gt;ChainedTransactionManager&lt;/code&gt; will not create any new Kafka transactions from any Kafka transaction managers provided to it. We still have a single JPA transaction to commit or roll back when exiting the user method. The Kafka transaction must wait until the call returns to the container to commit or rollback.&lt;/p&gt;
&lt;p&gt;The problem is that we use a function in Spring Cloud Stream that enables the framework to publish to Kafka. In our case, any user-specified transactions, such as the JPA one, occur before Spring Cloud Stream does the Kafka publishing. We need to ensure that the user code is the one that publishes to Kafka so that we can treat the entire transactional code as one unit. To achieve this, we should switch to a &lt;code&gt;Consumer&lt;/code&gt; instead of a &lt;code&gt;Function&lt;/code&gt; and then use the &lt;code&gt;StreamBridge&lt;/code&gt; API to publish to Kafka. Look at this modified code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
public Consumer&amp;#x3C;PersonEvent&gt; process(TxCode txCode) {
   return txCode::run;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we use the same TxCode as above:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
class TxCode {

   @Transactional
   void run(PersonEvent pe) {
       Person person = new Person();
       person.setName(pe.getName());

       Person savedPerson = repository.save(person);

       PersonEvent event = new PersonEvent();
       event.setName(savedPerson.getName());
       event.setType(&quot;PersonSaved&quot;);
       streamBridge.send(&quot;process-out-0&quot;, event);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that the run method does not return anything, but we explicitly send to the outbound Kafka topic through the &lt;code&gt;StreamBridge&lt;/code&gt; API.&lt;/p&gt;
&lt;h5 id=&quot;lets-look-at-the-sequence-of-events-with-these-changes&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#lets-look-at-the-sequence-of-events-with-these-changes&quot; aria-label=&quot;lets look at the sequence of events with these changes permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Let¡¯s look at the sequence of events with these changes&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;The Kafka consumer receives the record.&lt;/li&gt;
&lt;li&gt;The container in Spring Kafka invokes the listener by using the execute method of the TransactionTemplate.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KafkaTransactionManager&lt;/code&gt; starts a new transaction.&lt;/li&gt;
&lt;li&gt;The Kafka resources are bound (producer).&lt;/li&gt;
&lt;li&gt;When it gets to the user code, the interceptor intercepts that call and starts a new transaction by using the &lt;code&gt;JpaTransactionManager&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The actual user method is invoked.&lt;/li&gt;
&lt;li&gt;The Kafka send operation is made through &lt;code&gt;StreamBridge&lt;/code&gt; as part of the method execution. The underlying KafkaTemplate uses the same transactional producer factory bound in step 4.&lt;/li&gt;
&lt;li&gt;When the method exits, &lt;code&gt;JpaTransactionManager&lt;/code&gt; commits or rolls back.&lt;/li&gt;
&lt;li&gt;Finally, the control returns to the &lt;code&gt;TransactionTemplate#execute&lt;/code&gt; method when the Kafka transaction is committed (or rolled back).&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pay special attention to step 7 above. When &lt;code&gt;KafkaTemplate&lt;/code&gt; detects that there is already a Kafka transaction in progress (begun in step 3), it does not synchronize with the JPA transaction, although the &lt;code&gt;KafkaTemplate&lt;/code&gt; is capable of doing so. The existing Kafka transaction gets precedence, and it joins that transaction.&lt;/p&gt;
&lt;p&gt;Even though we still have two separate transactions, things are atomic from an end-to-end transactional standpoint. If the Kafka publishing operation through &lt;code&gt;StreamBridge&lt;/code&gt; fails, neither JPA nor Kafka transactions perform a commit operation. Both will roll back. Similarly, both transactions still roll back if the database operation fails. However, there is always the possibility that one transaction commits and the other rolls back, so the application code must handle the de-duplication of the records to be fault-tolerant.&lt;/p&gt;
&lt;p&gt;Another crucial component in this discussion of the &lt;strong&gt;consume-process-produce&lt;/strong&gt; pattern is that the producer needs to send the consumed record¡¯s offset (in addition to the consumer that commits the offset) to the transaction. As we saw in the &lt;a href=&quot;https://spring.io/blog/2023/09/27/introduction-to-transactions-in-spring-cloud-stream-kafka-applications&quot;&gt;first part&lt;/a&gt; of this blog series, there is a Kafka Producer API method called &lt;code&gt;sendOffsetToTransaction&lt;/code&gt; in which the producer sends an offset (the current message¡¯s offset + 1) for each partition through the &lt;code&gt;OffsetMetadata&lt;/code&gt; and the &lt;code&gt;ConsumerGroupMetadata&lt;/code&gt;. The applications do not need to call this low-level operation when using &lt;strong&gt;Spring Cloud Stream&lt;/strong&gt; or &lt;strong&gt;Spring for Apache Kafka&lt;/strong&gt;. The Kafka message listener container in Spring for Apache Kafka handles it automatically on behalf of the application. Although the framework calls &lt;code&gt;sendOffsetToTransaction&lt;/code&gt; on the producer before the transaction commits, sending the offsets to the transaction and the actual consumer offset commit occur atomically when the transaction coordinator commits the transaction.&lt;/p&gt;
&lt;p&gt;With this discussion, we ventured into the various options for writing transactional Spring Cloud Stream applications that must interact with external transactional systems, such as databases, while consuming and producing to Apache Kafka.&lt;/p&gt;
&lt;p&gt;In the next part of the series, we will look at transaction rolling back (another critical aspect when writing transactional systems) and how we can access the various Spring components while writing Spring Cloud Stream Kafka applications.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Shell 2.1.13, 3.0.8 and 3.1.4 are now available]]></title><link>https://spring.io/blog/2023/10/04/spring-shell-2-1-13-3-0-8-and-3-1-4-are-now-available</link><guid isPermaLink="true">https://spring.io/blog/2023/10/04/spring-shell-2-1-13-3-0-8-and-3-1-4-are-now-available</guid><dc:creator><![CDATA[Janne Valkealahti]]></dc:creator><pubDate>Wed, 04 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Spring Shell 2.1.13, 3.0.8 and 3.1.4 are now available&lt;/p&gt;
&lt;p&gt;On behalf of the team and everyone who has contributed, I&apos;m happy to announce that Spring Shell &lt;code&gt;2.1.13&lt;/code&gt;, &lt;code&gt;3.0.8&lt;/code&gt; and &lt;code&gt;3.1.4&lt;/code&gt; has been released and are now available from Maven Central.&lt;/p&gt;
&lt;p&gt;Please see the &lt;a href=&quot;https://github.com/spring-projects/spring-shell/releases/tag/v2.1.13&quot;&gt;release notes 2.1.13&lt;/a&gt;, &lt;a href=&quot;https://github.com/spring-projects/spring-shell/releases/tag/v3.0.8&quot;&gt;release notes 3.0.8&lt;/a&gt; and &lt;a href=&quot;https://github.com/spring-projects/spring-shell/releases/tag/v3.1.4&quot;&gt;release notes 3.1.4&lt;/a&gt; for more details.&lt;/p&gt;
&lt;p&gt;Thanks to all those who have contributed with issue reports and pull requests.&lt;/p&gt;
&lt;h3 id=&quot;how-can-you-help&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#how-can-you-help&quot; aria-label=&quot;how can you help permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;How can you help?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://spring.io/projects/spring-shell/&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-shell&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-shell/issues&quot;&gt;Issues&lt;/a&gt; | &lt;a href=&quot;https://docs.spring.io/spring-shell/docs/3.1.4/docs/index.html&quot;&gt;Documentation&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[This Week in Spring - October 3rd, 2023]]></title><link>https://spring.io/blog/2023/10/03/this-week-in-spring-october-3rd-2023</link><guid isPermaLink="true">https://spring.io/blog/2023/10/03/this-week-in-spring-october-3rd-2023</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Tue, 03 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi Spring fans! Welcome to another installment of &lt;em&gt;This Week in Spring&lt;/em&gt;! How&apos;re you doin&apos;? I&apos;ve just flown in from Singapore - where I was keynoting and presenting at SpringOne Singapore - and am now in Antwerp, Belgium for the deliriously fun Devoxx Belgium show. I&apos;ve missed this show, and it&apos;s a true pleasure to be back here! Next week, I&apos;ll be in Amsterdam, just next door, for the SpringOne Tour Amsterdam. If you&apos;re there, come out and say hi!&lt;/p&gt;
&lt;p&gt;We&apos;ve got a lot of stuff to look at this morning, so let&apos;s dive right into it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/09/28/a-bootiful-podcast-spring-ai-lead-dr-mark-pollack&quot;&gt;A Bootiful Podcast: Spring AI lead Dr. Mark Pollack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=bbzek2j3Yz0&quot;&gt;Building a ChatGPT clone with Spring Boot, LangChain, and React in 20 minutes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@anilfromdit/dockerize-your-spring-boot-app-like-a-pro-d1dd0ef37b79&quot;&gt;Dockerize Your Spring Boot App Like a Pro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hah. This is fun! &lt;a href=&quot;https://www.youtube.com/watch?v=0QVdJcxGf1M&quot;&gt;Generate Dynamic Websites using ChatGPT and Spring AI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;a new release of &lt;a href=&quot;https://github.com/toedter/spring-hateoas-jsonapi&quot;&gt;GitHub - toedter/spring-hateoas-jsonapi: A JSON:API media type implementation for Spring HATEOAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=74AEVZOBL88&quot;&gt;How To Log Outgoing HTTP Requests with Spring Rest Client and Spring Boot 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/09/27/introduction-to-transactions-in-spring-cloud-stream-kafka-applications&quot;&gt;Introduction to Transactions in Spring Cloud Stream Kafka Applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/09/29/spring-cloud-2023-0-0-m2-aka-leyton-has-been-released&quot;&gt;Spring Cloud 2023.0.0-M2 (aka Leyton) has been released&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://x.com/jimgris/status/1707824816835932410?s=12&amp;#x26;t=n-UflcIbnx1lage-TBk0Cg&quot;&gt;I&apos;ll be in Switzerland next week as well, and one of the people I am most looking forward to seeing is my friend Sam Brannen, major contributor to the JUnit project and lead of the Spring testing efforts. If you can&apos;t be there with us, you should enjoy this wonderful discussion between him and Oracle&apos;s Jim Grisanzio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://x.com/odrotbohm/status/1707038889909641224?s=12&amp;#x26;t=n-UflcIbnx1lage-TBk0Cg&quot;&gt;this is super cool: Spring Modulith made it into the Thoughtworks Technology Radar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/blog/2023/10/02/steering-committee-results-2023/&quot;&gt;Blog: Announcing the 2023 Steering Committee Election Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/blog/2023/09/26/happy-7th-birthday-kubeadm/&quot;&gt;Blog: Happy 7th Birthday kubeadm!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Spring Cloud 2023.0.0-M2 (aka Leyton) has been released]]></title><link>https://spring.io/blog/2023/09/29/spring-cloud-2023-0-0-m2-aka-leyton-has-been-released</link><guid isPermaLink="true">https://spring.io/blog/2023/09/29/spring-cloud-2023-0-0-m2-aka-leyton-has-been-released</guid><dc:creator><![CDATA[Olga Maciaszek-Sharma]]></dc:creator><pubDate>Fri, 29 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the community, I am pleased to announce that the Milestone 2 (M2) of the &lt;a href=&quot;https://cloud.spring.io&quot;&gt;Spring Cloud 2023.0&lt;/a&gt; Release Train is available today. The release can be found in &lt;a href=&quot;https://repo.spring.io/milestone/&quot;&gt;Spring Milestone&lt;/a&gt; repository. You can check out the 2023.0 &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2023.0-Release-Notes&quot;&gt;release notes for more information&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;notable-changes-in-the-202300-m2-release-train&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#notable-changes-in-the-202300-m2-release-train&quot; aria-label=&quot;notable changes in the 202300 m2 release train permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Notable Changes in the 2023.0.0-M2 Release Train&lt;/h2&gt;
&lt;p&gt;In this milestone, we have migrated the documentation of all the Spring Cloud projects to Antora.&lt;/p&gt;
&lt;p&gt;See all issues and pull requests &lt;a href=&quot;https://github.com/orgs/spring-cloud/projects/117/views/1&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;spring-cloud-commons&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#spring-cloud-commons&quot; aria-label=&quot;spring cloud commons permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Spring Cloud Commons&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Refresh Scope on restart - a feature tailored to allow adapting to environment changes on JVM Checkpoint-Restart (&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/pull/1266&quot;&gt;PR 1266&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;spring-cloud-gateway&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#spring-cloud-gateway&quot; aria-label=&quot;spring cloud gateway permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Spring Cloud Gateway&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Specify &lt;code&gt;clientRegistrationId&lt;/code&gt; in &lt;code&gt;TokenRelay&lt;/code&gt; filter. (&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-gateway/pull/2922&quot;&gt;PR 2922&lt;/a&gt;) The gateway can be used to manage many ClientRegistrations, and each route can determine which client registration to use. This is incredibly useful in scenarios where there are (for example):
&lt;ul&gt;
&lt;li&gt;multiple authorization servers in use simultaneously.&lt;/li&gt;
&lt;li&gt;multiple client authentication methods in use simultaneously.&lt;/li&gt;
&lt;li&gt;some/all downstream services require a distinct clientId, aud claim, etc.&lt;/li&gt;
&lt;li&gt;some/all downstream services require different token formats (e.g. JWT, opaque)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;spring-cloud-openfeign&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#spring-cloud-openfeign&quot; aria-label=&quot;spring cloud openfeign permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Spring Cloud OpenFeign&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Upgraded to Feign 12.5 (&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-openfeign/pull/907&quot;&gt;PR_907&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;spring-cloud-task&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#spring-cloud-task&quot; aria-label=&quot;spring cloud task permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Spring Cloud Task&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Users now have the ability to query for task executions using the external execution id. (&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-task/issues/863&quot;&gt;PR_863&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;spring-cloud-function&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#spring-cloud-function&quot; aria-label=&quot;spring cloud function permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Spring Cloud Function&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Users now have the ability to deploy REST applications as &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-starter-function-web&quot;&gt;AWS Lambdas or Azure Functions&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CRUD mappings for functions deployed as REST endpoints via &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-function/issues/1025&quot;&gt;spring-cloud-function-web&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;spring-cloud-stream&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#spring-cloud-stream&quot; aria-label=&quot;spring cloud stream permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Spring Cloud Stream&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Several important &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-stream/milestone/89?closed=1&quot;&gt;bug fixes and enhancements&lt;/a&gt; primarily related to Apache Kafka binders and new Apache Pulsar binder.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following modules were updated as part of 2023.0.0-M2:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Module&lt;/th&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;th&gt;Issues&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Consul&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-consul/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Gateway&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-gateway/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Zookeeper&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-zookeeper/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Bus&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-bus/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Stream&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-stream/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Function&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-function/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud OpenFeign&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-openfeign/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Vault&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-vault/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Commons&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Task&lt;/td&gt;
&lt;td&gt;3.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-task/releases/tag/v3.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Kubernetes&lt;/td&gt;
&lt;td&gt;3.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-kubernetes/releases/tag/v3.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Starter Build&lt;/td&gt;
&lt;td&gt;2023.0.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-starter-build/releases/tag/v2023.0.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Config&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-config/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Build&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-build/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Netflix&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-netflix/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud CircuitBreaker&lt;/td&gt;
&lt;td&gt;3.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-circuitbreaker/releases/tag/v3.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Contract&lt;/td&gt;
&lt;td&gt;4.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-contract/releases/tag/v4.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Cloud Task&lt;/td&gt;
&lt;td&gt;3.1.0-M2&lt;/td&gt;
&lt;td&gt;(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-contract/releases/tag/v3.1.0-M2&quot;&gt;issues&lt;/a&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As always, we welcome feedback on &lt;a href=&quot;https://github.com/spring-cloud/&quot;&gt;GitHub&lt;/a&gt;, on &lt;a href=&quot;https://stackoverflow.com/questions/tagged/spring-cloud&quot;&gt;Stack Overflow&lt;/a&gt;, or on &lt;a href=&quot;https://twitter.com/SpringCloud&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To get started with Maven with a BOM (dependency management only):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;#x3C;repositories&gt;
    &amp;#x3C;repository&gt;
        &amp;#x3C;id&gt;spring-milestones&amp;#x3C;/id&gt;
        &amp;#x3C;name&gt;Spring Milestones&amp;#x3C;/name&gt;
        &amp;#x3C;url&gt;https://repo.spring.io/milestone&amp;#x3C;/url&gt;
        &amp;#x3C;snapshots&gt;
            &amp;#x3C;enabled&gt;false&amp;#x3C;/enabled&gt;
        &amp;#x3C;/snapshots&gt;
    &amp;#x3C;/repository&gt;
&amp;#x3C;/repositories&gt;
&amp;#x3C;dependencyManagement&gt;
    &amp;#x3C;dependencies&gt;
        &amp;#x3C;dependency&gt;
            &amp;#x3C;groupId&gt;org.springframework.cloud&amp;#x3C;/groupId&gt;
            &amp;#x3C;artifactId&gt;spring-cloud-dependencies&amp;#x3C;/artifactId&gt;
            &amp;#x3C;version&gt;2023.0.0-M2&amp;#x3C;/version&gt;
            &amp;#x3C;type&gt;pom&amp;#x3C;/type&gt;
            &amp;#x3C;scope&gt;import&amp;#x3C;/scope&gt;
        &amp;#x3C;/dependency&gt;
    &amp;#x3C;/dependencies&gt;
&amp;#x3C;/dependencyManagement&gt;
&amp;#x3C;dependencies&gt;
    &amp;#x3C;dependency&gt;
        &amp;#x3C;groupId&gt;org.springframework.cloud&amp;#x3C;/groupId&gt;
        &amp;#x3C;artifactId&gt;spring-cloud-starter-config&amp;#x3C;/artifactId&gt;
    &amp;#x3C;/dependency&gt;
    &amp;#x3C;dependency&gt;
        &amp;#x3C;groupId&gt;org.springframework.cloud&amp;#x3C;/groupId&gt;
        &amp;#x3C;artifactId&gt;spring-cloud-starter-netflix-eureka-client&amp;#x3C;/artifactId&gt;
    &amp;#x3C;/dependency&gt;
    ...
&amp;#x3C;/dependencies&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or with Gradle:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-groovy&quot;&gt;plugins {
  id &apos;java&apos;
  id &apos;org.springframework.boot&apos; version &apos;3.2.0-M3&apos;
  id &apos;io.spring.dependency-management&apos; version &apos;1.1.3&apos;
}

group = &apos;com.example&apos;
version = &apos;0.0.1-SNAPSHOT&apos;

java {
  sourceCompatibility = &apos;17&apos;
}

repositories {
  mavenCentral()
  maven { url &apos;https://repo.spring.io/milestone&apos; }
}

ext {
  set(&apos;springCloudVersion&apos;, &quot;2023.0.0-M2&quot;)
}

dependencies {
  implementation &apos;org.springframework.cloud:spring-cloud-starter-config&apos;
  implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&apos;
  testImplementation &apos;org.springframework.boot:spring-boot-starter-test&apos;
}

dependencyManagement {
  imports {
    mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item></channel></rss>